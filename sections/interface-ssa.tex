\section{Interface}
\label{sec:interface-ssa}

While the core codebase has been designed and implemented
  to be easily accessible to those who wish to use it directly or extend it,
  the expected everyday interface to this project is
  the graphical tool presented below.
It fully supports the creation and automated testing of self-stabilizing algorithms.
It supports creating and documenting both predicates and moves
  using a combination of textual and graphical interfaces.
When such predicates and moves have been consolidated into a library,
  they can be assembled and organized into a self-stabilizing algorithm
  using a graphical interface.
  \todo[reword]{I feel like I'm using the word 'interface' too much}

All of these objects \Dash
  predicates, moves, and algorithms \Dash
  can be packaged into libraries that can be
  saved and distributed to colleagues.

\subsection{Predicates and Moves}
As reflected in the logical representation
  (see~\S\ref{sec:logic-repr:self-stab-algor}),
  self-stabilizing algorithms persist as a collection
  of predicates and moves.

\subsubsection{Creating}
Predicates and moves are created using a textual interface.
\todo[idea]{Could have some sort of 'raw logic' to python function processor.
  Does one exist?}
To create one of these entities,
  use \menu{File > New > Predicate\dots}
   or \menu{File > New > Move\dots}.
This presents you with a screen similar to~\autoref{fig:iface:create-pred},
  allowing you to provide the code (in Python~\autocite{python3:ref}).
A template is provided for you to begin working from,
  along with short examples of how to access nodes, edges, node data, and edge data.
(If you are familiar with the toole,
  the syntax is from NetworkX~\autocite{hagberg:networkx}.)
\begin{figure}
  \centering
  \includegraphics{example-image-a}
  \caption{When creating an entirely new predicate or move,
    you are presented with a helpful template to start working from.}
  \label{fig:iface:create-pred}
\end{figure}

\subsubsection{Documenting}
Every predicate and move can be given documentation.
In addition to human-readable documentation,
  \TeX nical documentation is also supported and encouraged.\footnote{%
    See~\autoref{sec:iface:export}.}
The documentation for predicates and moves is handled very Pythonically \Dash
  the first line of the function's docstring serves as \TeX nical documentation
  while the remaining text is considered the human-readable documentation.
Refer to~\autoref{lst:iface:pred-move-documentation} for an example.
\begin{lstlisting}[
  float,
  caption={An example of predicate\slash move documentation.},
  label={lst:iface:pred-move-documentation},
]
  def marked_alone(node, neighbors):
      """\forall n \in N(n), "marked"(n) = 0
  
      There are no marked nodes in this node's neighborhood."""
  
      return not any(map(lambda n: n['marked'], neighbors))
\end{lstlisting}

Note that there is a special notation for custom properties to ease its use.
When referring to a non-standard function
  \Dash such as "marked" \Dash
  you can enclose the function name in double quotes (the single character \texttt{\char`"}).
When exporting documentation,%
  \todo{Need a section for this \Dash exporting documentation.}
  this notation will be replaced by the more verbose
  (but typographically correct) "\operatorname{marked}".
See~\autoref{sec:iface:export} for more information.
\todo[code]{implement}

\subsubsection{Testing}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \tikzset{node/.style={minimum size=24pt}}
    \def\neighbors{9}
    \node[graph vertex] (source) at (0, 0) {$n$};
    \foreach \i in {1,...,\neighbors} {
      \node[graph vertex] (neighbor \i)
        at ({360/\neighbors * (\i - 1)}:1in) {$v_{\i}$};
      \path[graph undirected edge] (source) edge (neighbor \i);
    }
  \end{tikzpicture}
  \caption{An example of a star graph, more importantly realized as a
    node $n$ and its neighbors $v_i \in N(n)$.}
  \label{fig:iface:star-graph}
\end{figure}
Each predicate and move is tested on a star graph of varying size.
(See~\autoref{fig:iface:star-graph}.)
If a predicate is being tested and does not return a value that
  can be interpreted as \BooleanTrueValue\ or \BooleanFalseValue,
  the editor will not let you submit it to the database.
Similarly, if a move is being tested and does not return a node and a collection of nodes,
  it will not be internally marked as complete when saved.

When testing, you can set the properties of each node individually
  or load the entire from a supported data file (see~\autoref{sec:interface-testing:import}).
You can then step through each line of code to make sure it is acting as expected,
  while being able to see\slash inspect node data in real time.
\todo[code]{This may be \emph{very hard}, depending on tools available for the python debugger.
  IDLE manages it, but I'm not sure how yet.  Isn't it open source?}

\subsubsection{Maintaining}
\subsubsection{Distributing}

\subsection{Algorithms}

\subsubsection{Assembly}
\subsubsection{Documenting}
\subsubsection{Testing}
\subsubsection{Maintaining}
\subsubsection{Distributing}

\subsection{Collaboration}
\label{sec:iface:collab}
\subsubsection{Import}
\label{sec:iface:import}
\subsubsection{Export}
\label{sec:iface:export}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../smp.tex"
%%% reftex-cite-format: "\\autocite{%l}" 
%%% TeX-PDF-mode: t 
%%% TeX-command-default: "arara"
%%% End: 
