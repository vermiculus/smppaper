\section{Mathematical Definitions}
\label{sec:math-defin}

The core engine must be correct above all.
To prove its correctness, all necessary definitions will be
  presented, cited, and referred to throughout the remainder of the paper.

\subsection{Graph}
\label{sec:math-defin:graphs}

A \gls{graph} is a mathematical construct
  consisting of \glspl{node} (or \Term{vertices}) and \glspl{edge} between them:
  \begin{equation}
    \label{eq:define-graph}
    G = (V, E).
  \end{equation}
\done
\todo[ask]{graphs are also rep'd as sets of edges $v_1v_2$, but how are orphans notated? do I even need to worry about this?}

When any node $n$ is considered, we define its \gls{open neighborhood} in $G$ to be
  the set of all nodes $v$ such that $n$ is connected (or \Term{adjacent} to) $v$:
  \begin{equation}
    \label{eq:define-open-neighborhood}
    \OpenNeighborhood{n} = \Set{v}[(n, v) \in E]
  \end{equation}
  and the \gls{closed neighborhood} is defined as $n$ together with its neighbors:
  \todo[warn]{Yes, I know that my union notation for
    \eqref{eq:define-closed-neighborhood} (and others?) is nasty.
    I'm working on it, but the representation isn't a priority at this stage.
    (It's a \LaTeX 3 command that can take a comma-separated list of things to union
    and will then insert unions between them all.)}
  \begin{equation}
    \label{eq:define-closed-neighborhood}
    \ClosedNeighborhood{n} = \Union{\OpenNeighborhood{n}, \Set{n}}.
  \end{equation}

\subsection{Finite State Machine}
\label{sec:math-define:fsm}

A \gls{fsm} is a mathematical model of computation
  described by an alphabet $\Sigma$,
  a finite number of states $Q$,
  an initial state $q_0 \in Q$,
  a set of accept states $F \subseteq Q$,
  and a transition function $\Function[\delta]{Q \cross \Sigma}{Q}$ between those states.
Thus, a \gls{fsm} is defined by the five-tuple
  \[ M = (\Sigma, Q, q_0, F, \delta). \]
These can be represented as graphs where nodes are states in $Q$ and
  transitions are directed edges between them.
\todo[cite]{finite state machine}

\subsection{Self-Stabilizing Algorithm}
\label{sec:math-define:self-stab-algor}

As defined by \citeauthor{Dijkstra:1974:SSS:361179.361202}~\autocite{Dijkstra:1974:SSS:361179.361202},
  \done
  \todo{\texttt{citefield} the author}
  a self-stabilizing algorithm is a contruct composed of
  \glspl{predicate} and corresponding \glspl{move}.
Both are functions of a single node and its neighbors.\footnote{%
  Note that this is not the same as the closed neighborhood of a node.
  Consider these as functions $\Function{n, \OpenNeighborhood{n}}{\Set ?}$}
\Glspl{predicate} are functions to the Boolean values,
  \begin{equation}
  \label{eq:define-predicate}
  \Function[P]{n, \OpenNeighborhood{n}}{\SetBoolean},
  \end{equation}
  where each \gls{move} updates the state of the system:
  \begin{equation}
  \label{eq:define-move}
  \Function[M]{n, \OpenNeighborhood{n}}{n^\prime, \OpenNeighborhood[\prime]{n}}.
  \end{equation}
When a \gls{predicate} evaluates to $\BooleanTrueValue$ for any node $n$,
  it is said that $n$'s \gls{privilege} is \gls{present}.

A self-stabilizing algorithm can thus be seen as
  a collection of these \gls{predicate}--\gls{move} pairs.
Formally, we may define such an algorithm $S$ to be a discrete function
  from \glspl{predicate} to a random \gls{move} function:
  \begin{equation}
    \label{eq:define-ssalg}
    \Function[S]{P}{\operatorname{RandomChoice}(\Set{M_1, M_2, \dots, M_N})}
  \end{equation}
\done[Nope! Not really]
\todo[ask]{Is there a better way of describing random choice?
  Any conventions that are set, notationally speaking?}
It was defined in this way to clarify the logical representation of the algorithm;
  see Section~\ref{sec:logic-repr:self-stab-algor}.

Two properties of the algorithm must be shown
  for a self-stabilizing algorithm to be proven correct:~\autocite{arora:closure-and-convergence}
\begin{description}
\item[convergence] The algorithm must complete using a finite number of moves.
\item[closure] If the algorithm completes, the system is in a correct state.
  \done\todo[ask]{Determine the qualities of the algorithm that must be shown.}
\end{description}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../smp.tex"
%%% TeX-PDF-mode: t 
%%% reftex-cite-format: "\\autocite{%l}" 
%%% TeX-engine: xetex 
%%% End: 
