\section{Mathematical Definitions}
\label{sec:math-defin}

The core engine must be correct above all.
To prove its correctness, all necessary definitions will be
  presented, cited, and referred to throughout the remainder of the paper.

\subsection{Graph}
\label{sec:math-defin:graphs}

A graph is a mathematical construct
  consisting of vertices $V$ and edges $E$ between them: $G = (V, E)$.
\done[don't need to worry about it]
\todo[ask]{graphs are also rep'd as sets of edges $v_1v_2$, but how are orphans notated? do I even need to worry about this?}
We define its open neighborhood of $v \in G$ to be
  the set of all nodes $u$ such that $v$ is adjacent to $u$:
  $\OpenNeighborhood{n} = \Set{v}[(n, v) \in E]$
  and the closed neighborhood is defined as $v$ together with its neighbors:
  $\ClosedNeighborhood{n} = \Union{\OpenNeighborhood{n}, \Set{n}}$.

\begin{comment}
\subsection{Finite State Machine}
\label{sec:math-define:fsm}

A finite state machine (\textsc{fsm})
  \todo{use acro package}
  \todo{may not even \emph{need} this section}
  is a mathematical model of computation
  described by an alphabet $\Sigma$,
  a finite number of states $Q$,
  an initial state $q_0 \in Q$,
  a set of accept states $F \subseteq Q$,
  and a transition function $\Function[\delta]{Q \cross \Sigma}{Q}$ between those states.
Thus, a fsm is defined by the five-tuple %TODO
  \[ M = (\Sigma, Q, q_0, F, \delta). \]
These can be represented as graphs where nodes are states in $Q$ and
  transitions are directed edges between them.
\todo[cite]{finite state machine}
\end{comment}

\subsection{Self-Stabilizing Algorithm}
\label{sec:math-define:self-stab-algor}

As defined by \citeauthor{dew:sem}~\autocite{dew:sem},
  \done[Looks so much better this way]
  \todo{\texttt{citefield} the author}
  a self-stabilizing algorithm is a contruct composed of
  predicates and corresponding moves.
Both are functions of a single node and its neighbors.\footnote{%
  Note that this is not the same as the closed neighborhood of a node.
  Consider these as functions $\Function{n, \OpenNeighborhood{n}}{\Set ?}$}
Predicate are functions to the Boolean values,
  \begin{equation}
  \label{eq:define-predicate}
  \Function[P]{n, \OpenNeighborhood{n}}{\SetBoolean},
  \end{equation}
  where each move updates the state of the system:
  \begin{equation}
  \label{eq:define-move}
  \Function[M]{n, \OpenNeighborhood{n}}{n^\prime, \OpenNeighborhood[\prime]{n}}.
  \end{equation}
When a predicate evaluates to $\BooleanTrueValue$ for any node $n$,
  it is said that $n$'s privilege is present.

A self-stabilizing algorithm can thus be seen as
  a collection of these predicate--move pairs.
Formally, we may define such an algorithm $S$ to be a discrete function
  from predicates to a random move functions:
  \begin{equation}
    \label{eq:define-ssalg}
    \Function[S]{P}{\operatorname{RandomChoice}(\Set{M_1, M_2, \dots, M_N})}
  \end{equation}
\done[Nope! Not really]
\todo[ask]{Is there a better way of describing random choice?
  Any conventions that are set, notationally speaking?}
It was defined in this way to clarify the logical representation of the algorithm;
  see Section~\ref{sec:logic-repr:self-stab-algor}.
To distinguish from other uses of \Term{algorithm},
  this particular data structure will be called the \Term{ruleset}.

Two properties of the algorithm must be shown
  for a self-stabilizing algorithm to be proven correct:~\autocite{arora:closure-and-convergence}
\begin{description}
\item[convergence] The algorithm must complete using a finite number of moves.
\item[closure] If the algorithm completes, the system is in a correct state.
  \done[closure and convergence are \emph{it}]
  \todo[ask]{Determine the qualities of the algorithm that must be shown.}
\end{description}

A self-stabilizing algorithm converges if and only if
\todo[ask]{should this be a citation or a lemma?}
\begin{equation}
  \label{eq:define-ssalg:converge}
  \Exists{N \in \Naturals}{\ForAll{n > N, p \in P^n, v \in V}{p(v) = 0}}.
\end{equation}
That is, after some finite number of moves $N \in \Naturals$,
  no predicate $p \in P$ privileges any vertex $v \in G$.
\todo[ask]{Is there a mathematical way of expressing repeated application like this?
  Ask Susan or Sandy or one of the math profs if Alan doesn't know.}
If there are no privileged nodes, no node can make a move and
  the system is considered \Term{stable}~\autocite{dew:sem}.

A self-stabilizing algorithm satisfies closure if and only
  the absence of a privileged node necessarily implies a correct overall state:
\begin{equation}
  \label{eq:define-ssalg:closure}
  \Exists{N \in \Naturals}{\ForAll{n > N, p \in P^n, v \in V}{p(v) = 0}}
  \implies \text{$G$ is in a correct state}.
\end{equation}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../smp.tex"
%%% TeX-PDF-mode: t 
%%% reftex-cite-format: "\\autocite{%l}" 
%%% TeX-engine: xetex 
%%% TeX-command-default: "arara"
%%% End: 
