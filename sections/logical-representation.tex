\section{Logical Representation}
\label{sec:logic-repr}

The entirety of this tool is written in and tested with Python~3.
The following listings serve to introduce the organization of the library and
  to serve as a reference to be used when extending it.\footnote{%
    All development is tracked as a literate program on GitHub
    at \url{http://www.github.com/vermiculus/ssa-tool}.}

\subsection{Predicate and Moves}
\label{sec:logic-repr:predicate-move}

According to~\eqref{eq:define-predicate} and \eqref{eq:define-move},
  both predicates and moves are defined as simple functions of
  a node and its neighbors, where
  each predicate returns a Boolean value and
  each move returns an updated node and neighborhood.
In order for the tool to be useful however,
  there needs to be both documentation (discussed in \S\ref{iface:document:pred-move})
  and at least a few pieces of other metadata attached to these basic elements.
The population of this metadata is the responsibility of two distinct decorators
  \Dash "@predicate" and "@move" \Dash
  that take a number of arguments to provide mandatory metadata
  and also parse the following function's docstring
  to come up with the following standard pieces of metadata:
\begin{itemize}
\item mandatory metadata given as arguments to the decorator
  \begin{description}
  \item[author] author(s) of the function
  \item[version] version of the function
  \item[others\dots] any other optional metadata
  \end{description}
\item optional metadata parsed from docstring
  \begin{description}
  \item[summary] parsed from docstring; short summary of function
  \item[\TeX nical documentation] parsed from docstring; mathematical definition
  \item[long form] parsed from docstring; long form discussion of the function
  \end{description}
\end{itemize}
\autoref{lst:decorate:overview} provides the general structure for each decorator,
  where \autoref{lst:decorate:metadata} specifically provides the metadata to the function.
\lstinputlisting[
float,
caption={Predicates and moves are defined similarly as decorators to functions.},
label={lst:decorate:overview},
litkey=predicate,
]{src/core/Algorithm.org}
\lstinputlisting[
float,
caption={Each decorator defines some metadata for its function.},
label={lst:decorate:metadata},
litkey={define-metadata}
]{src/core/Algorithm.org}

\begin{warning}
  It is assumed that the actual neighborhood is given.
  This object is intended to be used only internally,
    and all \emph{internal} functions will indeed pass it the distance-1 neighborhood.
  It is left as an unintelligent definition to enable later extension.

  Note that there are \emph{absolutely no sanity checks} concerning
    the proper signatures of each function save only the number of arguments it takes.
  Any such checking would seem to be faulty for at least a small set of edge cases
    depending on the method taken.
  The only thing that can be reliably checked is the argument count of the function definition.
  (It is perhaps possible to parse the function definition's source code
    using the "inspect" module, but this is already well outside the scope of this first release.

  As such, it is critical to remember that predicates \emph{must} return a value
    that can at least be cast as a Boolean value (as "bool(...)" does).
  Likewise, moves \emph{must} return a "tuple" (or other indexed collection)
    that contains an updated node as the first index (index "0") and
    its updated neighborhood as the second (index "1").
\todo[code]{Make sure this is as advertised.}
\todo[code]{Perhaps this can be mitigated?
  Pass a simple star graph to the function to see if it returns the right thing?}
\end{warning}

\subsection{Self-Stabilizing Algorithm}
\label{sec:logic-repr:self-stab-algor}

According to~\eqref{eq:define-ssalg},
  a self-stabilizing algorithm is defined as a collection
  \Dash actually a \emph{mapping} \Dash 
  of these predicates to a set of their potential moves.
These must be provided as the constructor argument "ruleset",
  as in \autoref{lst:algorithm-init}.
\lstinputlisting[
float,
caption={According to~\eqref{eq:define-ssalg}, a self-stabilizing algorithm is exactly
  a set of rules from predicate to moves.},
label={lst:algorithm-init},
litkey=algorithm,
]{src/core/Algorithm.org}
In an \object{Algorithm}, the "ruleset" is assumed to have
  dictionary-like structure and behavior.
This is asserted within the constructor (as can be seen in~\autoref{lst:algorithm-type-check}),
  but perhaps the clearest definition of the structure can be given as an example.
Refer to \autoref{lst:algorithm-ex} for an example of this data structure.
\lstinputlisting[
float,
caption={An example structure to use as an \object{Algorithm}'s \texttt{\small ruleset}},
label={lst:algorithm-ex},
litkey=algorithm-ruleset-ex,
]{src/core/Algorithm.org}

\subsubsection{Type Checking}
\label{sec:logic-repr:self-stab-algor:type-checking}

\todo[reword]{awkward phrasing}
Since there is a strict definition on an algorithm's ruleset
  where neglecting to adhere to a specific format and behavior
  will cause other parts of the system to fail,
  a set of assertions is made upon "ruleset" that ensures at least non-crashing behavior.
These assertions (which can be reviewed in~\autoref{lst:algorithm-type-check}) check the following:
\begin{itemize}
\item "ruleset" is a collection that can be iterated upon directly,
\item all key-items in "ruleset" can be called directly,
\item all key-items in "ruleset" are functions of two arguments, and
\item all key-items in "ruleset" map to a collection of predicates, where
  \begin{itemize}
  \item each predicate can be called directly, and
  \item each predicate is a function of two arguments.
  \end{itemize}
\end{itemize}
It is quite possible that time could be saved by
  forgoing this initial type-check and simply assuming the behavior exists.
It is unknown to me whether dynamic error-catching (as in a "try"--"except" block)
  introduces a time constraint, where it would be far more detrimental to actual use.
\lstinputlisting[
float,
caption={Ensuring the rule-set we were given is usable as
  a definition of a self-stabilizing algorithm.},
label={lst:algorithm-type-check},
litkey={algorithm-ruleset-assertions},
]{src/core/Algorithm.py}

\subsection{Central Daemon}
\label{sec:logic-repr:daemon}

This implementation's testing model is based of the concept of a \Term{central daemon}.
(This was the first model explicitly introduced
  by \citeauthor{dew:sem}~\autocite{dew:sem}.)
The \object{Algorithm} class plays double-duty to fulfill this role as a default behavior,
  but perhaps this should be altered.
\todo[code]{Should \object{Algorithm} actually know how to run itself,
  or should a separate \object{Daemon} object be created to handle this?
  Honestly, I'm leaning toward the latter.}
The overall implementation and interface is available in~\autoref{lst:daemon-run},
  but we will look at each part individually.
\todo[code]{The algorithm should automatically stop when it has stabilized.}
\lstinputlisting[
float=p,
caption={A generalized run of a self-stabilizing algorithm.},
label={lst:daemon-run},
litkey={daemon-run},
]{src/core/Algorithm.org}
The daemon begins by finding assembling a list of privileged nodes.
To do this, it \emph{must} go through each node and check it for privilege.
\begin{warning}
  I consider this the greatest single bottleneck in the entire project.
  It is feasible that this can be altered into a distributed\slash threaded algorithm,
    but I haven't the knowledge to do so.
  The fact that predicates should \emph{never} write to a node or its neighbors
    allows this distribution of work among threads.
  This should be implemented in a future iteration.
\end{warning}
\lstinputlisting[
float=p,
caption={Finding privileged nodes.},
label={lst:daemon-find-privileged-nodes},
litkey={daemon-find-privileged-nodes},
]{src/core/Algorithm.org}

Within each iteration of the loop through the nodes in the graph
  (see~\autoref{lst:daemon-find-privileged-nodes}),
  we check to see if the node is privileged or not
  (see~\autoref{lst:daemon-get-privileges}).
If it is privileged, we add the privileged node to a dictionary called "privileged_nodes".
\begin{warning}
  We can also increase performance here with threading.
  Be careful of the difference, however:
    in the above we were simply reading information and
    running it through a predicate function.
  (In fact, we are doing the same here,
    but the above is a separate idea that can be sorted out.)
  The difference here is that we are altering the "privileged_nodes" data structure.
  The branch in~\autoref{lst:daemon-get-privileges} introduces a race condition:
    if two predicates $P_1, P_2$ simultaneously succeed for
    an as-yet unprivileged node $n$ at time $t$,
    time $t+1$ will result in only one unknown predicate
    $P_i$ being written to "privileged_nodes".
  Altering the data structure used for "privileged_nodes" may remove this limitation.
\end{warning}
\todo[code]{Perhaps we should just collect all predicate--move pairs in a set
  and randomly choose one?  This would be more statistically sound, but does it matter?}

\lstinputlisting[
float=p,
caption={Getting the privileges of a single node.},
label={lst:daemon-get-privileges},
litkey={daemon-get-privileges},
]{src/core/Algorithm.org}
\lstinputlisting[
float=p,
caption={Picking a random, satisfied predicate.},
label={lst:daemon-pick-predicate},
litkey={daemon-pick-predicate},
]{src/core/Algorithm.org}
\lstinputlisting[
float=p,
caption={Applying a random move enabled by the satisfied predicate.},
label={lst:daemon-apply-move},
litkey={daemon-apply-move},
]{src/core/Algorithm.org}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../smp.tex"
%%% TeX-PDF-mode: t 
%%% reftex-cite-format: "\\autocite{%l}" 
%%% TeX-command-default: "arara"
%%% TeX-engine: xetex
%%% End: 
