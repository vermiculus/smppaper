\section{Introduction}
\label{sec:introduction}
\subsection{Domain Introduction}
In his seminal paper on the topic~\autocite{dew:sem},
  \citeauthor{dew:sem} introduced the concept of
  self-stabilizing algorithms.
He visualized the realization of these algorithms as taking advantage of
  a very specific scenario:
\begin{displayquote}[\citeay{dew:sem}]
  We consider a connected graph in which
    the majority of the possible edges are missing and
    a finite state machine is placed at each node;
    machines placed in directly connected nodes are called each other's neighbors.
  For each machine one or more so-called \enquote{privileges} are defined,
    \ie boolean functions of its own state and the states of its neighbors;
    when such a boolean function is true,
    we say that the privilege is \enquote{present}.
  In order to model the undefined speed ratios of the various machines,
    we introduce a central daemon \Dash
    its replacement by a distributed daemon falls outside the scope of this article \Dash
    that can \enquote{select} one of the privileges present.
  The machine enjoying the selected privilege will then make its \enquote{move};
    \ie it is brought into a new state that is a function of
    its old state and the states of its neighbors.
  If for such a machine more than one privilege is present,
    the new state may also depend on the privilege selected.
  After completion of the move, the daemon will select a new privilege.
\end{displayquote}
This canonical definition is inherently limited, however;
  each node $n$ only knows the state of its distance-1 neighbors $v \in \ClosedNeighborhood{n}$.
\citeauthor{gairing:distance-2} introduced an approach for
  simulating distance-2 information~\autocite{gairing:distance-2},
  which was later generalized to simulating distance-$k$
  information~\autocite{goddard:ssa--k-distance} by~\citeauthor{goddard:ssa--k-distance}.
  (The approach necessarily introduced polynomial time and space complexities.)
\citeauthor{dew:sem}'s restrictive-yet-practical definition
  of a self-stabilizing algorithm
  was now \emph{far} less restrictive,
  since \citeauthor{goddard:ssa--k-distance} allowed \emph{any} distance-$k$ algorithm
  to be simulated in the original definition within a reasonable complexity increase.

Since then, many such algorithms have been put forward, unsurprisingly.
Talks like~\autocite{dolev:talk} present both
  applications of self-stabilization algorithms and
  research on the algorithms in general.
\todo[reword]{This phrasing is just plain weird and is not saying what I want it to say.}
Given their innately parallel nature,
  self-stabilizing algorithms are \emph{incredibly} useful
  for accurately modeling and solving real-world problems.

\subsection{Related Work}
\label{sec:introduction:related-work}
In the same vein, these algorithms can be incredibly hard to test
  \Dash let alone prove \Dash
  without spending significant time implementing the algorithm
  from scratch in a programming language.
This is a great barrier to some more mathematically-bent researchers in the field,
  given that they may have little to no experience in modeling mathematical systems as a program.
Even for those that \emph{are} comfortable with the practice,
  there are few tools that are readily available to assist in the work.
One that seems to stand out from the rest is Python's NetworkX~\autocite{hagberg:networkx},
  an extensive graph representation and manipulation library.
While these libraries assist in modeling the raw graph,
  they provide little to no assistance in creating, testing, or maintaining the algorithm itself.
They are simply not designed for such a relatively specific task.

This is not to say that there aren't many excellent frameworks in which
  to \emph{deploy} self-stabilizing algorithms.
For example, "libcircle" is \enquote{an API to provide an efficient distributed queue on a cluster}.
Using a blazingly fast algorithm described by~\autocite{lafon:libcircle},
  it is able to \enquote{quickly traverse and perform operations on a file tree
    which contains several hundred-million file nodes}.
This is a good tool to use, but is unfriendly as far as self-stabilization research is concerned.
The tool is written in and requires the use of C
  \Dash an \emph{excellent} choice of language in industries where speed is of the essence \Dash
  but it would seem unwise to create the algorithm itself
  by interactively testing with its use \Dash "ssa-tool" fills that hole.

On GitHub, "fintler/balancemq" provides another such API, this time written in Python,
  using an algorithm described by \autocite{lafon:balanceMQ}.
Again, while claiming to be an API for self-stabilizing algorithms,
  this (albeit useful) project does not provide true tools to create and work with
  fault-tolerant systems in the general case.
Nevertheless, these projects are excellent examples of the
  usefulness of these algorithms to the industry and
  the necessity of their existence and exploration.
\todo[cite]{How do I cite GitHub projects?
  I'm not sure who they're by, but they cite papers containing the algorithms used.}

It seems that this is partly due to the lack of definition as to
  \emph{what} exactly a self-stabilizing algorithm is.
\todo{Is this still valid?  Check sources.  I think I found rigorous definitions.  Cf. reflection.}

\begin{draftvspace}{2in}
  Expand on related work.
  There are a couple of other things available
    (see another reference~\autocite{lafon:libcircle}, for instance),
    but I've yet to do the necessary research to say \emph{what} exactly they do.
  All I know (and cared about) was that I wasn't \emph{duplicating} functionality.
\end{draftvspace}

\subsection{Current Work}
\label{sec:introduction:current-work}
This paper presents and defends such a tool-set
  along with a graphical utility to provide an easy interface and collaboration.
Complete with a graphical interface which supports
  maintaining libraries of \object{Predicate} and \object{Move} objects for later assembly,
  "ssa-tool" provides researchers with tools to test algorithms in batch and by hand.
\begin{draftvspace}{4in}
  Absolutely \emph{must} expand on this more.
  Go into what exactly happens, why it is necessary, what is possible, a potential use case, \dots.
\end{draftvspace}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../smp.tex"
%%% TeX-PDF-mode: t 
%%% reftex-cite-format: "\\autocite{%l}" 
%%% TeX-command-default: "arara"
%%% End: 
